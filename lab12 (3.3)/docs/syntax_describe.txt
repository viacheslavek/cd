Приведем описание абстрактного и конкретного синтаксиса для задания

Определения структур, объединений и перечислений языка Си.
В инициализаторах перечислений допустимы знаки операций +, -, *, /, sizeof,
операндами могут служить имена перечислимых значений и целые числа.

Числовые константы могут быть только целочисленными и десятичными.

Примеры синтаксиса можно увидеть в папке tests

Поначалу я составлял синтаксис сам, но спустя часы некорректного составления я обратился к стандарту
ISO/IEC 9899:1999 (E), где почерпнул некоторые идеи

Абстрактный синтаксис:

Program -> DeclarationList

DeclarationList -> Declaration*

Declaration -> TypeSpecifier AbstractDeclaratorsOpt ;


AbstractDeclaratorsOpt -> (AbstractDeclarators)?

AbstractDeclarators -> AbstractDeclarator (, AbstractDeclarator)*

AbstractDeclaratorOpt -> (AbstractDeclarator)?


AbstractDeclarator -> AbstractDeclaratorStar | AbstractDeclaratorArrayListOpt
AbstractDeclaratorStar -> STAR AbstractDeclarator

AbstractDeclaratorArrayListOpt -> (AbstractDeclaratorArrayList)?
AbstractDeclaratorArrayList -> AbstractDeclaratorArrayListOpt AbstractDeclaratorArray

AbstractDeclaratorArray -> AbstractDeclaratorArray [ Expression ] | AbstractDeclaratorPrim

AbstractDeclaratorPrim -> AbstractDeclaratorPrimSimple | AbstractDeclaratorPrimDifficult

AbstractDeclaratorPrimSimple -> IDENTIFIER
AbstractDeclaratorPrimDifficult -> ( AbstractDeclarator )


TypeSpecifier -> SimpleTypeSpecifier | EnumTypeSpecifier


SimpleTypeSpecifier -> SimpleType

SimpleType -> CHAR | SHORT | INT | LONG | FLOAT | DOUBLE | SIGNED | UNSIGNED


EnumTypeSpecifier -> ENUM EnumStatement

EnumStatement -> FullEnumStatement | EmptyEnumStatement

FullEnumStatement -> IdentifierOpt { EnumeratorList CommaOpt }

IdentifierOpt -> (IDENTIFIER)?

EmptyEnumStatement -> IDENTIFIER

EnumeratorList -> Enumerator (, Enumerator)*

Enumerator -> IDENTIFIER EnumeratorExpressionOpt

EnumeratorExpressionOpt -> (= ConstantExpression)?


CommaOpt -> (,)?


ConstantExpression -> Expression

Expression -> IDENTIFIER | INT | Expression BinOp Expression | UnOp Expression
BinaryOperation -> + | - | * | /
UnaryOperation -> + | - | sizeof ( TypeSpecifier AbstractDeclaratorsOpt )


StructOrUnionSpecifier -> StructOrUnion StructOrUnionStatement

StructOrUnion -> STRUCT | UNION

StructOrUnionStatement -> FullStructOrUnionStatement | EmptyStructOrUnionStatement

EmptyStructOrUnionStatement -> IDENTIFIER

FullStructOrUnionStatement -> IdentifierOpt { DeclarationList }




Конкретный синтаксис:

Program -> DeclarationList

DeclarationList -> Declaration | DeclarationList Declaration

Declaration -> TypeSpecifier AbstractDeclaratorsOpt ;


AbstractDeclaratorsOpt -> AbstractDeclaratorList | ε

AbstractDeclaratorList -> AbstractDeclaratorList , AbstractDeclarator | AbstractDeclarator

AbstractDeclarator -> AbstractDeclaratorStar | AbstractDeclaratorArrayList
AbstractDeclaratorPointer -> STAR AbstractDeclarator

AbstractDeclaratorArrayList -> AbstractDeclaratorArrayList AbstractDeclaratorArray | AbstractDeclaratorArray

AbstractDeclaratorArray -> [ Expression ] | AbstractDeclaratorPrim

AbstractDeclaratorPrim -> AbstractDeclaratorPrimSimple | AbstractDeclaratorPrimDifficult

AbstractDeclaratorPrimSimple -> IDENTIFIER
AbstractDeclaratorPrimDifficult -> ( AbstractDeclarator )


TypeSpecifier -> SimpleTypeSpecifier | EnumTypeSpecifier


SimpleTypeSpecifier -> SimpleType

SimpleType -> CHAR | SHORT | INT | LONG | FLOAT | DOUBLE | SIGNED | UNSIGNED


EnumTypeSpecifier -> ENUM EnumStatement

EnumStatement -> FullEnumStatement | EmptyEnumStatement

FullEnumStatement -> IdentifierOpt { EnumeratorList CommaOpt }

IdentifierOpt -> IDENTIFIER | ε

EmptyEnumStatement -> IDENTIFIER

EnumeratorList -> EnumeratorList , Enumerator | Enumerator

Enumerator -> IDENTIFIER EnumeratorExpressionOpt

EnumeratorExpressionOpt -> = ConstantExpression | ε


CommaOpt -> , | ε


ConstantExpression -> Expression

Expression -> ArithmeticExpression

ArithmeticExpression -> Term | + Term | - Term | ArithmeticExpression AddOperation Term

AddOperation -> + | -

Term -> Factor | Term MultyOperation Factor
MultyOperation -> * | /

Factor -> sizeof ( TypeSpecifier AbstractDeclaratorsOpt ) | IDENTIFIER | INT | ( Expression )


StructOrUnionSpecifier -> StructOrUnion StructOrUnionStatement

StructOrUnion -> STRUCT | UNION

StructOrUnionStatement -> FullStructOrUnionStatement | EmptyStructOrUnionStatement

EmptyStructOrUnionStatement -> IDENTIFIER

FullStructOrUnionStatement -> IdentifierOpt { DeclarationList }


Проверки:

1) Теги структур, теги перечислений и теги объединений не должны повторяться.
За это отвечает терминал IDENTIFIER, он при объявлении в
    - NAbstractDeclaratorPrimSimple -> готово

    - NEmptyEnumStatement -> в процессе
    - NIdentifierOpt в NFullEnumStatement

    - NEmptyStructOrUnionStatement
    - NIdentifierOpt в NFullStructOrUnionStatement

Добавляются в глобальный мапу esuIdent (упорядоченный). Если он повторяется, то ошибка.


2) Enum’ы определяют глобальные константы, они тоже не должны повторяться.
То есть при встрече в NEnumerator IDENT я добавляю его в constName мапу.
В нем нет повторений и он обязательно упорядоченный. Иначе - ошибка
При добавлении я сохраняю имя как ключ и expression как значение.
Expression потом можно будет сразу считать. Если Expression пуст, то добавляю номер в массиве в значение.


3) В структурах и объединениях не могут встречаться одноимённые поля.
В NFullStructOrUnionStatement в NDeclarationList
не должно быть совпадающих NAbstractDeclaratorPrimSimple на одном уровне.


4) Используемые идентификаторы должны быть определены выше по тексту.
Если попадаем в NFactor, то он должен быть либо в esuIdent, либо в constName. Иначе ошибка



